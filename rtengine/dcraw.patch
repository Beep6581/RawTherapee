--- dcraw.c	2011-02-06 12:06:14.000000000 -0600
+++ dcraw.cc	2011-02-06 12:04:45.000000000 -0600
@@ -1,3 +1,12 @@
+/*RT*/#include <glib.h>
+/*RT*/#include <glib/gstdio.h>
+/*RT*/#undef MAX
+/*RT*/#undef MIN
+/*RT*/#define NO_LCMS
+/*RT*/#define NO_JPEG
+/*RT*/#define LOCALTIME
+/*RT*/#define DJGPP
+
 /*
    dcraw.c -- Dave Coffin's raw photo decoder
    Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net
@@ -96,11 +105,12 @@
 typedef unsigned char uchar;
 typedef unsigned short ushort;
 
+#include "dcraw.h"
 /*
    All global variables are defined here, and all functions that
    access them are prefixed with "CLASS".  Note that a thread-safe
    C++ class cannot have non-const static local variables.
- */
+
 FILE *ifp, *ofp;
 short order;
 const char *ifname;
@@ -128,13 +138,13 @@
 int output_color=1, output_bps=8, output_tiff=0, med_passes=0;
 int no_auto_bright=0;
 unsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };
-float cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];
-const double xyz_rgb[3][3] = {			/* XYZ from RGB */
+float cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];*/
+const double xyz_rgb[3][3] = {			// XYZ from RGB
   { 0.412453, 0.357580, 0.180423 },
   { 0.212671, 0.715160, 0.072169 },
   { 0.019334, 0.119193, 0.950227 } };
 const float d65_white[3] = { 0.950456, 1, 1.088754 };
-int histogram[4][0x2000];
+/*int histogram[4][0x2000];
 void (*write_thumb)(), (*write_fun)();
 void (*load_raw)(), (*thumb_load_raw)();
 jmp_buf failure;
@@ -152,8 +162,8 @@
   int format, key_off, black, black_off, split_col, tag_21a;
   float tag_210;
 } ph1;
-
-#define CLASS
+*/
+#define CLASS DCraw::
 
 #define FORC(cnt) for (c=0; c < cnt; c++)
 #define FORC3 FORC(3)
@@ -271,6 +281,7 @@
       fprintf (stderr,_("Corrupt data near 0x%llx\n"), (INT64) ftello(ifp));
   }
   data_error++;
+  /*RT*/  longjmp (failure, 1);
 }
 
 ushort CLASS sget2 (uchar *s)
@@ -344,7 +355,7 @@
 {
   if (fread (pixel, 2, count, ifp) < count) derror();
   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
-    swab (pixel, pixel, count*2);
+    swab ((char*)pixel, (char*)pixel, count*2);
 }
 
 void CLASS canon_600_fixed_wb (int temp)
@@ -536,10 +547,10 @@
    getbits(-1) initializes the buffer
    getbits(n) where 0 <= n <= 25 returns an n-bit integer
  */
-unsigned CLASS getbithuff (int nbits, ushort *huff)
+unsigned CLASS getbithuff_t::operator() (int nbits, ushort *huff)
 {
-  static unsigned bitbuf=0;
-  static int vbits=0, reset=0;
+/*RT static unsigned bitbuf=0; */
+/*RT static int vbits=0, reset=0; */
   unsigned c;
 
   if (nbits == -1)
@@ -1286,7 +1297,7 @@
   free (pixel);
 }
 
-void CLASS jpeg_thumb();
+/*RT  void CLASS jpeg_thumb(); */
 
 void CLASS ppm_thumb()
 {
@@ -1562,10 +1573,10 @@
   phase_one_correct();
 }
 
-unsigned CLASS ph1_bithuff (int nbits, ushort *huff)
+unsigned CLASS ph1_bithuff_t::operator() (int nbits, ushort *huff)
 {
-  static UINT64 bitbuf=0;
-  static int vbits=0;
+/*RT  static UINT64 bitbuf=0; */
+/*RT  static int vbits=0; */
   unsigned c;
 
   if (nbits == -1)
@@ -1691,7 +1702,7 @@
   }
 }
 
-void CLASS unpacked_load_raw();
+/*RT void CLASS unpacked_load_raw(); */
 
 void CLASS sinar_4shot_load_raw()
 {
@@ -1832,10 +1843,10 @@
   maximum = 0x3ff;
 }
 
-unsigned CLASS pana_bits (int nbits)
+unsigned CLASS pana_bits_t::operator() (int nbits)
 {
-  static uchar buf[0x4000];
-  static int vbits;
+/*RT  static uchar buf[0x4000]; */
+/*RT  static int vbits;*/
   int byte;
 
   if (!nbits) return vbits=0;
@@ -2124,11 +2135,11 @@
 METHODDEF(boolean)
 fill_input_buffer (j_decompress_ptr cinfo)
 {
-  static uchar jpeg_buffer[4096];
+/*RT  static uchar jpeg_buffer[4096]; */
   size_t nbytes;
 
   nbytes = fread (jpeg_buffer, 1, 4096, ifp);
-  swab (jpeg_buffer, jpeg_buffer, nbytes);
+  swab ((char*)jpeg_buffer, (char*)jpeg_buffer, nbytes);
   cinfo->src->next_input_byte = jpeg_buffer;
   cinfo->src->bytes_in_buffer = nbytes;
   return TRUE;
@@ -2400,9 +2411,9 @@
   maximum = (1 << (thumb_misc & 31)) - 1;
 }
 
-void CLASS sony_decrypt (unsigned *data, int len, int start, int key)
+void CLASS sony_decrypt_t::operator()(unsigned *data, int len, int start, int key)
 {
-  static unsigned pad[128], p;
+/*RT  static unsigned pad[128], p;*/
 
   if (start) {
     for (p=0; p < 4; p++)
@@ -2649,7 +2660,7 @@
 
 void CLASS foveon_decoder (unsigned size, unsigned code)
 {
-  static unsigned huff[1024];
+/*RT  static unsigned huff[1024];*/
   struct decode *cur;
   int i, len;
 
@@ -4333,7 +4344,7 @@
   }
 }
 
-int CLASS parse_tiff_ifd (int base);
+/*RT int CLASS parse_tiff_ifd (int base);*/
 
 void CLASS parse_makernote (int base, int uptag)
 {
@@ -4461,7 +4472,7 @@
     }
     if (tag == 0xd && type == 7 && get2() == 0xaaaa) {
       fread (buf97, 1, sizeof buf97, ifp);
-      i = (uchar *) memmem (buf97, sizeof buf97,"\xbb\xbb",2) - buf97 + 10;
+      i = (uchar *) memmem ((char*) buf97, sizeof buf97,"\xbb\xbb",2) - buf97 + 10;
       if (i < 70 && buf97[i] < 3)
 	flip = "065"[buf97[i]]-'0';
     }
@@ -4844,8 +4855,8 @@
   }
 }
 
-void CLASS parse_minolta (int base);
-int CLASS parse_tiff (int base);
+/*RT void CLASS parse_minolta (int base); */
+/*RT int CLASS parse_tiff (int base);*/
 
 int CLASS parse_tiff_ifd (int base)
 {
@@ -4859,7 +4870,7 @@
   unsigned sony_curve[] = { 0,0,0,0,0,4095 };
   unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;
   struct jhead jh;
-  FILE *sfp;
+/*RT*/  IMFILE *sfp;
 
   if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])
     return 1;
@@ -5274,12 +5285,13 @@
     fread (buf, sony_length, 1, ifp);
     sony_decrypt (buf, sony_length/4, 1, sony_key);
     sfp = ifp;
-    if ((ifp = tmpfile())) {
-      fwrite (buf, sony_length, 1, ifp);
-      fseek (ifp, 0, SEEK_SET);
+/*RT*/    ifp = fopen (buf, sony_length);
+//    if ((ifp = tmpfile())) {
+//      fwrite (buf, sony_length, 1, ifp);
+//      fseek (ifp, 0, SEEK_SET);
       parse_tiff_ifd (-sony_offset);
-      fclose (ifp);
-    }
+//      fclose (ifp);
+//    }
     ifp = sfp;
     free (buf);
   }
@@ -5304,6 +5316,8 @@
 {
   int doff;
 
+  /*RT*/  if (exif_base == -1) exif_base = base;
+
   fseek (ifp, base, SEEK_SET);
   order = get2();
   if (order != 0x4949 && order != 0x4d4d) return 0;
@@ -5478,7 +5492,7 @@
 {
   const char *file, *ext;
   char *jname, *jfile, *jext;
-  FILE *save=ifp;
+/*RT*/  IMFILE *save=ifp;
 
   ext  = strrchr (ifname, '.');
   file = strrchr (ifname, '/');
@@ -5506,7 +5520,8 @@
       *jext = '0';
     }
   if (strcmp (jname, ifname)) {
-    if ((ifp = fopen (jname, "rb"))) {
+/*RT*/    if ((ifp = fopen (jname))) {
+//    if ((ifp = fopen (jname, "rb"))) {
       if (verbose)
 	fprintf (stderr,_("Reading metadata from %s ...\n"), jname);
       parse_tiff (12);
@@ -5844,7 +5859,11 @@
     order = get2();
     hlen  = get4();
     if (get4() == 0x48454150)		/* "HEAP" */
-      parse_ciff (save+hlen, len-hlen);
+/*RT*/    {
+/*RT*/      ciff_base = save+hlen;
+/*RT*/      ciff_len = len-hlen;
+        parse_ciff (save+hlen, len-hlen);
+/*RT*/    }
     if (parse_tiff (save+6)) apply_tiff();
     fseek (ifp, save+len, SEEK_SET);
   }
@@ -6879,6 +6898,12 @@
   fread (head, 1, 32, ifp);
   fseek (ifp, 0, SEEK_END);
   flen = fsize = ftell(ifp);
+
+  /*RT*/ if (fsize<100000) {
+        is_raw = 0;
+        return;
+    }
+
   if ((cp = (char *) memmem (head, 32, "MMMM", 4)) ||
       (cp = (char *) memmem (head, 32, "IIII", 4))) {
     parse_phase_one (cp-head);
@@ -6886,6 +6911,8 @@
   } else if (order == 0x4949 || order == 0x4d4d) {
     if (!memcmp (head+6,"HEAPCCDR",8)) {
       data_offset = hlen;
+/*RT*/      ciff_base = hlen;
+/*RT*/      ciff_len = fsize - hlen;
       parse_ciff (hlen, flen - hlen);
     } else if (parse_tiff(0)) apply_tiff();
   } else if (!memcmp (head,"\xff\xd8\xff\xe1",4) &&
@@ -6927,6 +6954,7 @@
     fseek (ifp, 100, SEEK_SET);
     parse_tiff (data_offset = get4());
     parse_tiff (thumb_offset+12);
+/*RT*/    exif_base = thumb_offset+12;
     apply_tiff();
   } else if (!memcmp (head,"RIFF",4)) {
     fseek (ifp, 0, SEEK_SET);
@@ -7009,7 +7037,7 @@
   if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */
     { height  = 3124;   width  = 4688; filters = 0x16161616; }
   if (!strcmp(model,"K-r") || !strcmp(model,"K-x"))
-    {			width  = 4309; filters = 0x16161616; }
+    {			width  = 4308; filters = 0x16161616; }
   if (!strcmp(model,"K-5"))
     { left_margin = 10; width  = 4950; filters = 0x16161616; }
   if (!strcmp(model,"K-7"))
@@ -7365,6 +7393,9 @@
   } else if (!strcmp(model,"D1X")) {
     width -= 4;
     pixel_aspect = 0.5;
+  } else if (!strcmp(model,"D3100")) {
+    width -= 24;
+    left_margin = 4;
   } else if (!strcmp(model,"D40X") ||
 	     !strcmp(model,"D60")  ||
 	     !strcmp(model,"D80")  ||
@@ -8591,13 +8622,13 @@
 	   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;
       else FORCC ppm2[col*colors+c] = curve[image[soff][c]];
     if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)
-      swab (ppm2, ppm2, width*colors*2);
+      swab ((char*)ppm2, (char*)ppm2, width*colors*2);
     fwrite (ppm, colors*output_bps/8, width, ofp);
   }
   free (ppm);
 }
 
-int CLASS main (int argc, const char **argv)
+/*int CLASS main (int argc, const char **argv)
 {
   int arg, status=0;
   int timestamp_only=0, thumbnail_only=0, identify_only=0;
@@ -8710,7 +8741,7 @@
       case 'i':  identify_only     = 1;  break;
       case 'c':  write_to_stdout   = 1;  break;
       case 'v':  verbose           = 1;  break;
-      case 'h':  half_size         = 1;		/* "-h" implies "-f" */
+      case 'h':  half_size         = 1;		// "-h" implies "-f"
       case 'f':  four_color_rgb    = 1;  break;
       case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);
       case 'a':  use_auto_wb       = 1;  break;
@@ -8973,3 +9004,4 @@
   }
   return status;
 }
+*/
