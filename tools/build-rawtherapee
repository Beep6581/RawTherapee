#!/usr/bin/env bash
# By Morgan Hardwood
# Version 2022-01-04
# This script gets the latest source code for the given program and compiles it.

# Function to retrieve the absolute path to the folder of this script, also works with symlinks
# Inspired by https://stackoverflow.com/questions/59895/how-can-i-get-the-source-directory-of-a-bash-script-from-within-the-script-itsel
function get_absolute_path_to_script_folder() {
    SOURCE=${BASH_SOURCE[0]}
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        TARGET=$(readlink "$SOURCE")
        if [[ $TARGET == /* ]]; then
            SOURCE=$TARGET
        else
            DIR=$(dirname "$SOURCE")
            SOURCE=$DIR/$TARGET # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
        fi
    done
    DIR=$(cd -P "$(dirname "$SOURCE")" &> /dev/null && pwd)
    echo $DIR
}

# The name of the program, used for the folder names:
prog="rawtherapee"

# The name of the compiled executable:
exe="${prog}"

# Install folder:
installFolderLocal="$HOME/programs"
installFolderSystem="/opt"
# default install folder:
installFolder="$installFolderLocal"

# Discovered repo folder (containing this script)
repoFolder=$(realpath "$(get_absolute_path_to_script_folder)/..")

# The name of the sub-folder, if any, relative to the folder into which the
# compiled executable is placed.
# e.g. If the executable ends up in:
#   ~/programs/someProgram/foo/bar/someExecutable
# then set it to:
#   exeRelativePath="foo/bar"
# or if the executable ends up in
#   ~/programs/someProgram/someExecutable
# then leave it empty:
# exeRelativePath=""
exeRelativePath=""

# The path to the repository:
repo="https://github.com/Beep6581/RawTherapee.git"

# No touching below this line, with the exception of the "Compile" section
# -----------------------------------------------------------------------------

# The name of the project's standard branch, typically "master":
master="dev"

buildOnly="false"
buildType="release"

# Removes the trailing forward-slash if one is present
exeRelativePath="${exeRelativePath/%\/}"
# Append forward-slash to exeRelativePath only if it is not empty.
exePath="${exeRelativePath:+${exeRelativePath}/}${exe}"

# Command-line arguments
sudo=""
OPTIND=1
while getopts "bdsh?-" opt; do
    case "${opt}" in
        b)  buildOnly="true"
            ;;
        d)  buildType="debug"
            ;;
		s)
			sudo="sudo "
            installFolder="$installFolderSystem"
			;;            
        h|\?|-) printf '%s\n' "This script gets the latest source code for ${prog}, compiles and installs it to $installFolder." \
                "Options:" \
                "  -b" \
                "     Optional. If specified, the script only compiles the source, it does not try to update the source." \
                "     If not specified, the source will be updated first." \
                "  -d" \
                "     Optional. Compile a \"debug\" build. If not specified, a \"release\" build will be made." \
                "  -s" \
                "     Optional. System wide installation to $installFolderSystem." \
                ""
        exit 0
        ;;
    esac
done

shift $((OPTIND-1))
[ "$1" = "--" ] && shift

printf '%s\n' "" "Found $prog repo: $repoFolder" "Program name: ${prog}" \
                 "Build type: ${buildType}" "Build without updating: ${buildOnly}" \
                 "Install folder: ${installFolder}" ""

# Clone if needed
cloned="false"
updates="false"
if [[ ! -d "$repoFolder" ]]; then
    mkdir -p "$HOME/programs" || exit 1
    git clone "$repo" "$repoFolder" || exit 1
    pushd "$repoFolder" 1>/dev/null || exit 1
    cloned="true"
else
    pushd "$repoFolder" 1>/dev/null || exit 1
    git fetch || exit 1
    if [[ $(git rev-parse HEAD) != $(git rev-parse '@{u}') ]]; then
        updates="true"
    fi
fi

# Pull updates if necessary
if [[ "$updates" = "true" && "$buildOnly" = "false" ]]; then
    git pull || exit 1
fi

# Find out which branch git is on
branch="$(git rev-parse --abbrev-ref HEAD)" || exit 1

# Set build and install folder names
if [[ $branch = $master && $buildType = release ]]; then
    buildDir="${repoFolder}/build"
    installDir="${installFolder}/${prog}"
else
    buildDir="${repoFolder}/build-${branch}-${buildType}"
    installDir="${installFolder}/${prog}-${branch}-${buildType}"
fi

existsExe="false"
if [[ -e "${installDir}/${exePath}" ]]; then
    existsExe="true"
fi

# Quit if no updates and build-only flag not set
if [[ "$cloned" = "false" && "$buildOnly" = "false" && "$updates" = "false" && "$existsExe" = "true" ]]; then
    printf '%s\n' "No updates, nothing to do."
    exit 0
fi

# Determine CPU count
cpuCount=1
if command -v nproc &>/dev/null; then
    cpuCount="$(nproc --all)"
else 
    echo "Couldn't determine CPU core count (program `nproc` is missing), using $cpuCount build process(es)"
fi

# Create build folder
mkdir -p "${buildDir}" || exit 1
cd "${buildDir}" || exit 1

# -----------------------------------------------------------------------------
# Compile

# See:
# http://rawpedia.rawtherapee.com/Linux#Compile_RawTherapee

cmake \
    -DCMAKE_BUILD_TYPE="$buildType"  \
    -DCACHE_NAME_SUFFIX="5-dev" \
    -DPROC_TARGET_NUMBER="2" \
    -DBUILD_BUNDLE="ON" \
    -DBUNDLE_BASE_INSTALL_DIR="${installDir}" \
    -DOPTION_OMP="ON" \
    -DWITH_LTO="OFF" \
    -DWITH_PROF="OFF" \
    -DWITH_SAN="OFF" \
    -DWITH_SYSTEM_KLT="OFF" \
    -DWITH_BENCHMARK="OFF" \
    "$repoFolder" || exit 1

echo "Compiling with $cpuCount threads"

make --jobs="$cpuCount" || exit 1

echo "Installing to $installDir"
${sudo}rm -rf "${installDir}" || exit 1
${sudo}mkdir -p "${installDir}"  || exit 1
${sudo}make install || exit 1

# Finished
printf '%s\n' "" "To run ${prog} type:" "${installDir}/${exePath}" ""

popd 1>/dev/null
